---
title: Creating maps with R and OpenStreetMap (2)
author: Florian Zenoni
date: '2017-11-07'
categories:
  - OpenStreetMap
  - R
tags:
  - OpenStreetMap
  - sf
  - tmap
  - osmdata
slug: creating-maps-coastlines
---

```{r, echo=FALSE}
# CONFIG
user_name <- "fzenoni" # your Git username (only needed if
# you want to deploy to GH pages)
project_name <- "coast-map" # adapt!
package_date <- "2017-11-07" # date of the CRAN snapshot that
# the checkpoint package uses
```

### GitHub

The code for the herein described process can also be freely downloaded from [https://github.com/`r user_name`/`r project_name`](https://github.com/`r user_name`/`r project_name`). 

```{r include=FALSE}
detach_all_packages <- function() {
  basic_packages_blank <-  c("stats",
    "graphics",
    "grDevices",
    "utils",
    "datasets",
    "methods",
    "base")
  basic_packages <- paste("package:", basic_packages_blank, sep = "")
  
  package_list <- search()[
    ifelse(unlist(gregexpr("package:", search())) == 1, TRUE, FALSE)]
  
  package_list <- setdiff(package_list, basic_packages)
  
  if (length(package_list) > 0)  for (package in package_list) {
    detach(package, character.only = TRUE, unload = TRUE)
    print(paste("package ", package, " detached", sep = ""))
  }
}

detach_all_packages()

# this allows multiple persons to use the same RMarkdown
# without adjusting the working directory by themselves all the time
source("scripts/csf.R")
path_to_wd <- csf() # if this - for some reason - does not work, 
# replace with a hardcoded path, like so: "~/projects/rddj-template/analysis/"
if ( is.null(path_to_wd) | !dir.exists(path_to_wd)) {
  print("WARNING: No working directory specified for current user")
} else {
  setwd(path_to_wd)
}
```

```{r message=FALSE, warning=FALSE, include=FALSE}
# from https://mran.revolutionanalytics.com/web/packages/checkpoint/vignettes/using-checkpoint-with-knitr.html
# if you don't need a package, remove it from here (commenting is probably not sufficient)
# tidyverse: see https://blog.rstudio.org/2016/09/15/tidyverse-1-0-0/
cat("
library(backports)
library(dplyr)
library(osmdata)
library(sf)
library(knitr)
library(tmap)",
  file = "manifest.R")
```

```{r message=FALSE, warning=FALSE, include=FALSE}
# if checkpoint is not yet installed, install it (for people using this
# system for the first time)
if (!require(checkpoint)) {
  if (!require(devtools)) {
    install.packages("devtools", repos = "http://cran.us.r-project.org")
    require(devtools)
  }
  devtools::install_github("checkpoint",
    username = "RevolutionAnalytics",
    ref = "v0.3.2", # could be adapted later,
    # as of now (beginning of July 2017
    # this is the current release on CRAN)
    repos = "http://cran.us.r-project.org")
  require(checkpoint)
}
# nolint start
if (!dir.exists("~/.checkpoint")) {
  dir.create("~/.checkpoint")
}
# nolint end
# install packages for the specified CRAN snapshot date
checkpoint(snapshotDate = package_date,
  project = path_to_wd,
  verbose = T,
  scanForPackages = T,
  use.knitr = F)
rm(package_date)
```

```{r message=FALSE, warning=FALSE, include=FALSE}
source("manifest.R")
unlink("manifest.R")
# sessionInfo()
```

## Where were we

In the previous post (click [here](https://altran-data-analytics.netlify.com/2017/10/10/2017-10-10-creating-maps-with-r-and-openstreetmap/) if you missed it), we managed to put together a relatively short chunk of code that generated the following rather nice map of Brussels Region, which includes all of its 19 municipalities.

```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
boundaries <- opq(bbox = 'Brussels, Belgium') %>%
  add_osm_feature(key = 'admin_level', value = '8') %>% 
  osmdata_sf %>% unique_osmdata
municipalities <- boundaries$osm_multipolygons
regions <- opq(bbox = 'Brussels, Belgium') %>%
  add_osm_feature(key = 'admin_level', value = '4') %>% 
  osmdata_sf %>% unique_osmdata
bxl_region <- regions$osm_multipolygons %>% filter(osm_id == '54094')

municipalities <- st_transform(municipalities, 3812)
bxl_region <- st_transform(bxl_region, 3812)
# Fix the polygons before the intersection, or it will fail
if(!all(st_is_valid(municipalities))) {
  municipalities <- municipalities %>% st_make_valid()
}

neg_buffer <- st_buffer(bxl_region, -100) # in meters
bxl_municipalities_poly <- municipalities[neg_buffer, ]

# Drop the municipalities factors excluded from the latest subset operations
# or they will appear in the legend.
bxl_municipalities_poly <- bxl_municipalities_poly %>% mutate(name = droplevels(name))

tm_style_col_blind() +
  tm_shape(bxl_municipalities_poly) +
  tm_polygons(title = 'Brussels Capital Municipalities', border.col = 'grey40', col = 'name', alpha = 0.6) +
  tm_shape(bxl_region) + tm_borders(col = 'grey20', lwd = 2, alpha = 0.8) +
  tm_layout(legend.outside = TRUE, frame.double.line = TRUE) +
  tm_grid(projection = 'longlat', n.x = 5) + tm_scale_bar() +
  tm_compass(position = c('right', 'top'))
```

In that post, we discussed how a certain amount of challenges were overcome. We picked Brussels, a city that lays in mainland. As a consequence, we did not have to worry about what stands _around_ Brussels, because it wouldn't have added much information to our map. But what if instead we decided to display a city on the coast? Let's choose a warmer place, such as Bilbao, Spain! Besides the presence of the sea, this choice will give us the chance check how to visualize the Bilbao estuary, and possibly the flowing river.

I should specify that `tmap` gives you the chance to superimpose your queries to the OpenStreetMap map tiles, by creating an interactive HTML widget. This could be the shortest possible answer to display the region of interest in its geographical context. To showcase this let's begin once again by the fundamentals. We are going to query the administrative level 7, corresponding the the _comarca_ of Greater Bilbao (some sort of county).

```{r}
boundaries <- opq(bbox = 'Bilbao, Spain') %>%
  add_osm_feature(key = 'admin_level', value = '7') %>% 
  osmdata_sf %>% unique_osmdata
```

Now let's activate the "view" option (the default being "plot"), and let's display the single region we queried.

```{r message=FALSE}
tmap_mode('view')
qtm(boundaries$osm_multipolygons)
# Reset to default
tmap_mode('plot')
```

Cool. But certainly boring.

We know how to query boundaries with `osmdata`; nothing stops us from querying a coastline.
But first, I will define a slightly larger bounding box, so that later we'll have some margin of adjustement.

```{r}
bb <- st_bbox(boundaries$osm_multipolygons)
# Defining a buffer
buffer <- 0.1
p_big <- rbind(c(bb[1] - buffer, bb[2] - buffer),
  c(bb[1] - buffer, bb[4] + buffer),
  c(bb[3] + buffer, bb[4] + buffer),
  c(bb[3] + buffer, bb[2] - buffer),
  c(bb[1] - buffer, bb[2] - buffer))
# Putting the coordinates into a formal square
pol <- st_polygon(list(p_big)) %>% st_geometry
st_crs(pol) <- 4326
```

The correct `key` and `value` to obtain the coastline are `natural` and `coastline` (check the [wiki page](http://wiki.openstreetmap.org/wiki/Tag:natural%3Dcoastline) for more details).

```{r}
coast <- opq(bbox = st_bbox(pol)) %>%
  add_osm_feature(key = 'natural', value = 'coastline') %>%
  osmdata_sf %>% unique_osmdata

qtm(coast$osm_lines)
```

Interesting already! We got Bilbao's coastline, some tiny islands here and there, as well as the estuary.
We can quickly superimpose what we have.

```{r}
qtm(boundaries$osm_multipolygons) + qtm(coast$osm_lines)
```

Is there more to it? Can we see the rest of the river?
I am going to query any OSM object carrying the key "waterway".

```{r}
water <- opq(bbox = st_bbox(pol)) %>%
  add_osm_feature(key = 'waterway') %>%
  osmdata_sf %>% unique_osmdata
```

After a quick inspection, it seems that the watercourses are represented as polygons. Let's add them to the rest.

```{r}
qtm(boundaries$osm_multipolygons) + qtm(coast$osm_lines) + qtm(water$osm_polygons)
```

It is a very rough visualization, but all the elements are here.

Now, apart from some fine tuning, no map of a coastal city would be complete without appropriate colors for sea and land. If land (and islands) and sea were univoquely represented by polygons, this would be an easy task. Instead, all we have, at least for the coastline, is a line. The strategy would then be to cut the polygon frame in two parts, according to the coast, acting as a "blade". Luckily for us, the `sf` package includes many of the functions usually available in PostGIS. This time, 

```{r}
blade <- coast$osm_lines %>% st_union %>% st_line_merge
multipol <- st_split(st_geometry(pol), st_geometry(blade))

land <- st_cast(multipol[[1]], 'POLYGON') %>% st_geometry %>% st_sf
st_crs(land) <- 4326

sea <- st_difference(pol, land) %>% st_geometry %>% st_sf
st_crs(sea) <- 4326

tm_shape(land) + tm_polygons(col = 'bisque3') +
  tm_shape(boundaries$osm_multipolygons, is.master = T) + tm_polygons() +
  tm_shape(sea) + tm_polygons(col = 'skyblue') +
  tm_shape(water$osm_polygons) + tm_polygons(col = 'skyblue')

# qtm(st_geometry(land), col = 'bisque3') + qtm(st_geometry(sea)) + qtm(boundaries$osm_multipolygons, is.master = T)
```
